---
title: 计算机视觉入门必备工具
top: false
cover: false
toc: true
mathjax: false
comments: true
lang: zh-CN
summary: 介绍如何利用 Git 与 GitHub 获取计算机视觉项目。
tags:
  - git
  - github
categories: 教程
abbrlink: ad2d8036
date: 2019-09-14 10:40:44
updated:
password:
---

随着 GPU 和大量优质数据的出现，深度学习技术在计算机视觉任务中扮演着越来越重要的角色。深度学习技术的端到端的模式大大简化了特征工程的工作量，为提取更加有效的特征提供了一个泛化性更强的工具。故而，学习深度学习技术是计算机视觉任务的不二之选。

一般地，学习深度学习技术需要具备以下能力：

- 编程语言：当前，大多数深度学习框架均以 Python 为主流编程语言。您可以阅读 Python 官方教程：[中文 Python](https://docs.python.org/zh-cn/3/)。
- 版本控制：一个深度学习项目不是一天建成，需要不断的调试和修复，因而学习**版本控制**是十分重要的任务。本文仅仅介绍 Git。
- 解读和使用优质的 GitHub 资源：如果所有的项目都从零开始构建是完全没有必要的，将项目建立在优秀的 GitHub 项目的基础上，继续开发，将会为您节省大量的时间和经历。本文将详细介绍如何使用 GitHub 资源。

## 1 Git 基础

![git 速查表](http://justinhileman.info/article/git-pretty/git-pretty.png)

Git 学习资源：

- [Git 基础：Pro Git](https://git-scm.com/book/zh/v2)
- [Git 进阶](https://git-scm.com/doc/ext)
- PDF 版命令手册：[github-git-cheat-sheet.pdf](https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf)
- Git 完整命令手册地址：[http://git-scm.com/docs](http://git-scm.com/docs)
- [图解 Git](http://marklodato.github.io/visual-git-guide/index-zh-cn.html)

所谓的**版本控制**，就是用来记录文件内容的变动，方便未来查询和恢复文件的内容修订的一种系统。版本控制的工具有很多，但是，我比较倾向于 Git。因为 Git 是**分布式的**，即使服务器上的版本库坏掉了，您也可以从其他非服务器的电脑上进行版本更新。

> 并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。—— 《Git Pro》

您完全不用担心把文件玩坏，因为版本控制已经帮你准备好了时光机器，借由版本控制您可以追溯文件的前世、今生以及未来，文件的时间轴完全由您掌控，甚至于，您可以借助 Git 的**分支**跳跃不同的“平行宇宙”。

Git 数据库中保存的信息都是以**文件内容的哈希值**来索引，而不是文件名。Git 有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。

- **已提交**表示数据已经安全的保存在本地**Git 仓库目录**（即 `.git` 目录，*是 Git 用来保存项目的元数据和对象数据库的地方。 供其它计算机克拷贝的数据。*）中。
- **已修改**表示修改了文件，但还没保存到**Git 仓库目录**中。
- **已暂存**表示在**工作目录**（即您磁盘上存储的你看到的数据）对一个已修改文件的当前版本做了标记（即记录在 `.git/index` 中，一般地，将其称为**暂存区域**），使之包含在下次提交的快照中。

### 1.1 配置用户信息

一般情况下，安装好 Git 之后需要您配置用户信息，用于记录提交者的信息。

```sh
$ git config --global user.name 用户名
$ git config --global user.email 邮箱
```

配置好了用户信息，之后您便可以使用 Git 了。如果您不知道某一个命令如何使用，您可以使用 `git help` 来获取帮助，比如：

```sh
$ git help config
```

您便轻松的获取 `git config` 的离线帮助文档。

### 1.2 创建并操作一个本地仓库

创建一个本地仓库，只需要您在工作目录下使用命令 `git init` 即可。此命令会在工作目录的根目录下创建 `.git` 目录，即本地的 Git 仓库。但是，此时，您的 Git 本地仓库是空的，我们需要将工作目录中的文件加入 Git 的跟踪：

![git init](init.png)

命令 `git add .` 将工作目录的所有文件由未跟踪状态转换为跟踪状态，并存储在暂存区（注意，这里说“存储”并不准确，应该说是将文件的内容的指针放入 `.git/index` 中进行存储）。如果您仅仅只需要跟踪 `A.md`，那么您可以这样：

```sh
$ git add A.md
```

vscode（一个十分强大的编辑器） 可以显示追踪的状态：

![git add](add.png)

为了查看文件存储的状态，您可以使用 `git staus -s`：

![git status](modify.png)

`git status` 仅仅可以看出文件级别的不同状态，而如果您想要获悉文件的内容之间的不同，可以使用 `git diff` 获取工作目录中当前文件和暂存区域快照之间的差异：

![git diff](diff.png)

`git diff` 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动，若要查看已暂存的将要添加到下次提交里的内容，可以用 `git diff --staged` 命令。

您总会有一些文件不希望被 Git 追踪（比如一些机密文件），此时您可以创建文件 `.gitignore` 并将那些不希望被追踪的文件名称写入到 `.gitignore` 中（在 <https://github.com/github/gitignore> 中提供了一些 `.gitignore` 模板可供参考）。文件 `.gitignore` 的格式规范如下：

- 所有空行或者以 `#` 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。
- 以（`/`）开头防止递归。
- 以（`/`）结尾指定目录。
- 惊叹号（`!`）取反要忽略指定模式以外的文件或目录。

当您通过 `git status` 查看文件的状态为均已经暂存时，您便可以使用 `git commit -m "提交的信息"` 命令将文件的变动提交到仓库了。提交时记录的是放在暂存区域的快照，并以 SHA-1 校验码进行标识方便之后的版本转换。更多命令可以由下图解读：

```mermaid
graph LR
A(History) --git reset -- files--> B(Staged)
B --git checkout -- files--> C(Working Directory)
B --git commit -m --> A
C --git add files--> B
C --git commit -a -m --> A
A --git checkout HEAD -- files--> C
```

如果您已经做了多次提交，那么 Git 会将您的提交的顺序进行记录，通过 `git log` 命令可以查看您的提交历史。（更多关于 `git log` 的用法请参阅 <https://git-scm.com/book/zh/v2/Git-基础-查看提交历史>）。而您的每次提交均被 Git 以 SHA-1 码记录，这样一来，您便可以依据其将工作目录恢复到某个过去的时间节点。假如，您已经回到工作目录过去的某个时间节点，而您又想回到未来（相对于当前时间节点），那么，您可以借助 `git reflog` 来查找“未来”的时间节点，然后使用 `git checkout ID` 进行穿梭（ID 指的是 SHA-1 码）。工作目录的时间节点的状态是由 HEAD 进行指示的，故而，您也可以使用 `git reset --hard commit_id` 不断的切换 HEAD 达到穿梭时间的效果。

有时候您提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行 `git commit -a -m` 提交命令尝试重新提交（其中 `-a` 表示 `--amend`）。

### 1.3 远程仓库

上一节您已经了解了然后创建一个本地仓库，并对该本地仓库进行管理。本节我们探讨**远程仓库**（远程仓库是指托管在服务器或其他网络中的你的项目的版本库）。因为该仓库仅仅作为合作媒介，不需要从磁盘检查快照，所以一个远程仓库通常只是一个**裸仓库**（bare repository，一个没有当前工作目录的仓库，即工程目录内的 `.git` 目录）。

创建一个裸仓库，只需要：

```sh
$ git clone --bare my_project my_project.git
```

该命令实现了将 `my_project/.git` 复制到 `my_project.git` 目录中的作用，而 `my_project.git` 便是一个裸仓库。为了让裸仓库发挥分布式的作用，需要将其放到服务器上并设置你的协议。其他拥有服务器的访问或读写权限的电脑将可以通过如下方式进行复刻：

```sh
$ git clone user@git.example.com:/opt/git/my_project.git
```

其中， `user@git.example.com` 代表服务器的地址，而 `/opt/git/my_project.git` 代表服务器上裸仓库所在路径。本文不展开说明如何构建服务器，如果您想要了解构建服务器的详细信息，可以查看：[服务器上的 Git - 在服务器上搭建 Git](https://git-scm.com/book/zh/v2/服务器上的-Git-在服务器上搭建-Git)（<https://git-scm.com/book/zh/v2/服务器上的-Git-在服务器上搭建-Git>） 或者 GitBlit（<http://gitblit.com/>）。本文将使用目前最大的 Git 托管平台——GitHub 这一 Git 服务器（详细内容见 <https://git-scm.com/book/zh/v2/GitHub-账户的创建和配置>）。

假如从 GitHub 上搜寻到一个不错的仓库，您想要将其加入到自己的项目中去，您可以这样做：

![fork](fork.png)

点击右边的 `fork` 按钮，然后，选择您的用户名或者组织，将其复刻下来。这样，您便有了对该仓库的读写以及**推送**（将本地仓库同步到远端仓库）的权限。使用 `git clone` 的命令将远端仓库克隆到本地，克隆的网址可以这样获取：

![git clone](clone.png)

当您克隆到本地后，可以使用 `git remote -v` 命令查看远程仓库使用的 Git 保存的简写与其对应的 URL，比如：

```sh
origin  https://github.com/xinetzone/xinet-matery.git (fetch)
origin  https://github.com/xinetzone/xinet-matery.git (push)
```

其中 `origin` 便是别名。如果您想要拥有多个远程仓库，可以运行 `git remote add <shortname> <url>` 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写。

为了方便说明我们创建两个本地仓库 `server/D.git` 与 `server/R.git`，然后在目录 `T` 中添加这两个仓库：

![git remote add](remote.png)

从上图可以看出，目录 `T` 下有两个远程仓库，它们的别名分别为：`D` 与 `R`。现在您可以在命令行中使用字符串 `D` 来代替整个 URL。 例如，如果你想拉取 `D` 所指代的仓库,可以运行 `git fetch D`，这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，接着，您运行 `git merge D/master` 命令便可以将 `D` 合并到当前目录。

如果你使用 `git clone` 命令克隆了一个仓库，该命令会自动将其添加为远程仓库并默认以 "origin" 为简写。

如果您在当前工作目录下做了修改，并且，想要将其分享，只需要执行 `git push [remote-name] [branch-name]` 命令即可。比如：

```sh
$ git push D master
```

如果您想查看远程仓库的更多详细信息，可以运行 `git remote show [remote-name]`；如果您想要重命名引用的名称可以运行 `git remote rename`；如果您想要删除远程仓库可以运行 `git remote rm`。

### 1.4 标签

[2.6 Git 基础 - 打标签](https://git-scm.com/book/zh/v2/Git-基础-打标签)

### 1.5 分支

前面的内容，我们仅仅涉及 mater 分支，

[3.1 Git 分支 - 分支简介](https://git-scm.com/book/zh/v2/Git-分支-分支简介)

### 1.6

#### 1.6.1 HEAD

HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 你的上一次提交 的快照。
其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：

https://www.runoob.com/manual/git-guide/

http://marklodato.github.io/visual-git-guide/index-zh-cn.html

https://git-scm.com/book/zh/v2/Git-工具-重置揭密#r_git_reset

https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440

https://git-scm.com/book/zh/v2/分布式-Git-分布式工作流程

https://git-scm.com/book/zh/v2/GitHub-对项目做出贡献